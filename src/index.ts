import * as core from '@actions/core';
import { createAIProvider, AIProviderType } from './ai/factory';
import { GitHubService } from './github/github.service';
import { ConfigLoader } from './config/config.loader';
 import { DiffParser } from './utils/diff.parser';
import * as dotenv from 'dotenv';

// Load env vars for local development if needed
dotenv.config();

async function run() {
    try {
        // 1. Get Inputs
        const deepseekApiKey = core.getInput('deepseek_api_key') || process.env.DEEPSEEK_API_KEY || '';
        const githubToken = core.getInput('github_token') || process.env.GITHUB_TOKEN || '';
        const rulesFilePath = core.getInput('rules_file') || '.review-rules.md';
        let modelName = core.getInput('model_name') || 'deepseek-chat';

        core.info(`Provider: DeepSeek`);
        core.info(`Model: ${modelName}`);

        if (!githubToken) {
            throw new Error('GitHub Token is required (input: github_token or env: GITHUB_TOKEN)');
        }

        if (!deepseekApiKey) {
            throw new Error('DeepSeek API Key is required (input: deepseek_api_key or env: DEEPSEEK_API_KEY)');
        }

        // 2. Initialize Services
        const aiProvider = createAIProvider(deepseekApiKey, AIProviderType.DEEPSEEK);
        const githubService = new GitHubService(githubToken);

        // 3. Load Rules/Instructions
        let rulesContent = '';
        try {
            rulesContent = ConfigLoader.loadRules(rulesFilePath);
            core.info(`Loaded review rules from ${rulesFilePath}`);
        } catch (error) {
            core.warning(`Could not load rules file at ${rulesFilePath}. Using default generic instructions.`);
            rulesContent = "Follow best practices for clean, efficient, and secure code.";
        }

        // 4. Fetch PR Diff
        core.info('Fetching PR diff...');
        const diff = await githubService.getPRDiff();

        // Basic check to avoid sending empty diffs
        if (!diff || diff.length === 0) {
            core.info('No changes detected in diff. Skipping review.');
            return;
        }

        // 4.1. Extract file paths from diff and fetch full file contents
        core.info('Parsing diff to extract modified files...');
        const parsedFiles = DiffParser.parse(diff);
        const modifiedFilePaths = DiffParser.getModifiedFilePaths(parsedFiles);

        core.info(`Found ${modifiedFilePaths.length} modified file(s). Fetching full content for better context...`);
        const fileContents = new Map<string, string>();

        for (const filePath of modifiedFilePaths) {
            try {
                const content = await githubService.getFileContent(filePath);
                if (content) {
                    fileContents.set(filePath, content);
                    core.info(`âœ“ Fetched content for: ${filePath}`);
                }
            } catch (error) {
                core.warning(`Failed to fetch content for ${filePath}: ${error}`);
            }
        }

        // 5. Generate Review
        core.info(`Generating review using DeepSeek model: ${modelName}...`);
        const reviewResult = await aiProvider.reviewCode({
            diff,
            instructions: rulesContent,
            model: modelName,
            fileContents
        });

        // 6. Post Review (Inline Comments + Summary)
        core.info('Posting review to GitHub...');
        const summary = `## ðŸ¤– AI Code Review\n\n${reviewResult.review}\n\n---\n*Generated by mik-review-ai using DeepSeek-V3.2*`;
        
        await githubService.postReview(summary, reviewResult.comments || []);

        core.info('Review completed successfully.');

    } catch (error) {
        if (error instanceof Error) {
            core.setFailed(error.message);
        } else {
            core.setFailed('An unexpected error occurred.');
        }
    }
}

run();